<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Double-Jump Obstacle Runner</title>
  <style>
    :root { --bg:#0b1020; --fg:#e6f0ff; --accent:#6ae3ff; --accent2:#8af78d; --danger:#ff7a93; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1020,#0a0f1a);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";color:var(--fg)}
    .wrap{max-width:960px;margin:0 auto;padding:16px}
    h1{font-size:clamp(20px,3vw,28px);margin:12px 0 4px}
    .panel{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{appearance:none;border:none;background:linear-gradient(135deg,var(--accent),#62a8ff);color:#032; padding:10px 14px;border-radius:14px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.25);transition:transform .1s ease,filter .2s ease}
    .btn:hover{filter:saturate(1.2)}
    .btn:active{transform:translateY(1px)}
    .stat{display:flex;gap:10px;align-items:center}
    .badge{background:#0f172a;border:1px solid #19324f;color:#bfe8ff;padding:8px 10px;border-radius:12px;font-weight:600}
    canvas{width:100%;height:auto;border-radius:18px;display:block;background:radial-gradient(60% 120% at 50% -10%, #1b2442 0%, #0b1020 60%);}    
    .hint{opacity:.85;font-size:14px;margin:8px 0 0}
    .credits{opacity:.6;font-size:13px;margin-top:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Double-Jump Obstacle Runner</h1>
    <div class="panel">
      <div class="stat">
        <span class="badge">คะแนน: <span id="score">0</span></span>
        <span class="badge">ดีที่สุด: <span id="best">0</span></span>
        <span class="badge">ความเร็ว: <span id="spd">1.0x</span></span>
      </div>
      <div class="stat">
        <button class="btn" id="startBtn">▶ เริ่ม / เล่นใหม่</button>
        <button class="btn" id="pauseBtn">⏸ หยุดชั่วคราว (P)</button>
      </div>
    </div>
    <canvas id="game" width="960" height="540"></canvas>
    <p class="hint">ควบคุม: <strong>Space / W / ↑ / คลิก / แตะ</strong> เพื่อกระโดด (กดซ้ำกลางอากาศเพื่อ <strong>Double Jump</strong>) กด <strong>P</strong> เพื่อหยุดชั่วคราว</p>
    <p class="credits">อุปสรรคเป็นเสาทั้งด้านบนและด้านล่าง ความสูง/ช่องว่างสุ่ม ปรับความเร็วตามคะแนน มีระบบ <em>coyote time</em> และ <em>jump buffer</em> ให้ควบคุมลื่นไหล</p>
  </div>

  <script>
    // ====== Canvas + DPR ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    function fitCanvasToDPR() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const { width, height } = canvas;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return dpr;
    }
    let DPR = fitCanvasToDPR();
    addEventListener('resize', () => { DPR = fitCanvasToDPR(); });

    // ====== Game State ======
    const state = {
      running:false, paused:false, time:0, score:0, best: Number(localStorage.getItem('dj_best')||0),
      speed: 5, baseSpeed:5, spawnEvery: 95, obstacles:[], particles:[],
    };

    // ====== Player ======
    const player = {
      x: 180, y: 360, w: 24, h: 24, vx:0, vy:0,
      gravity: 0.6, jumpV: -10.5, jump2V: -9.0,
      grounded:false, jumpsLeft:2, coyoteTime:0, jumpBuffer:0,
      color:'#8af78d', trail:[]
    };

    function resetGame(){
      state.running = true; state.paused=false; state.time=0; state.score=0;
      state.speed = state.baseSpeed; state.obstacles.length=0; state.particles.length=0;
      player.y = 360; player.vx=0; player.vy=0; player.grounded=false; player.jumpsLeft=2; player.coyoteTime=0; player.jumpBuffer=0; player.trail.length=0;
    }

    // ====== Input ======
    function wantJump(){ player.jumpBuffer = 8; }
    addEventListener('keydown', (e)=>{ 
      if(['Space','KeyW','ArrowUp'].includes(e.code)) { e.preventDefault(); wantJump(); }
      if(e.code==='KeyP') togglePause();
    });
    addEventListener('mousedown', wantJump);
    addEventListener('touchstart', (e)=>{ e.preventDefault(); wantJump(); }, {passive:false});

    function tryJump(){
      if (player.grounded || player.coyoteTime>0) {
        player.vy = player.jumpV; player.grounded=false; player.jumpsLeft=1; player.coyoteTime=0;
        spawnBurst(player.x+player.w/2, player.y+player.h, 10, '#8af78d'); return true;
      } else if (player.jumpsLeft>0) {
        player.vy = player.jump2V; player.jumpsLeft=0;
        spawnBurst(player.x+player.w/2, player.y+player.h, 10, '#6ae3ff'); return true;
      }
      return false;
    }

    // ====== Obstacles (top & bottom) ======
    function spawnObstacle(){
      const gapMin = 110, gapMax = 170; 
      const gap = rand(gapMin, gapMax);
      const minTop = 30, minBottom = 30;
      const maxTop = 300;
      let topLen = rand(minTop, maxTop);
      let bottomLen = Math.max(minBottom, (canvas.height/DPR) - (topLen + gap));
      if (Math.random()<0.4){
        const tweak = rand(-80, 80);
        topLen = clamp(topLen + tweak, minTop, 360);
        bottomLen = Math.max(minBottom, (canvas.height/DPR) - (topLen + gap));
      }
      const w = rand(40, 68);
      const x = (canvas.width/DPR) + w;
      const type = Math.random()<0.2 ? 'single' : 'pair';
      if (type==='pair') {
        state.obstacles.push({x, w, top: topLen, bottom: bottomLen, passed:false});
      } else {
        const isTop = Math.random()<0.5;
        state.obstacles.push({x, w, top: isTop? rand(80, 360): 0, bottom: isTop? 0: rand(80, 360), passed:false});
      }
    }

    // ====== Particles ======
    function spawnBurst(x,y,n,color){
      for(let i=0;i<n;i++){
        state.particles.push({x,y, vx:(Math.random()*2-1)*2, vy:-(Math.random()*2)*1.5, life: 30+Math.random()*20, color});
      }
    }
    function updateParticles(){
      for (const p of state.particles){ p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.life-=1; }
      state.particles = state.particles.filter(p=>p.life>0);
    }

    // ====== Loop ======
    let spawnTimer = 0, prevGrounded = true;
    function step(){
      if(!state.running){ drawSplash(); return requestAnimationFrame(step); }
      if(state.paused){ drawPaused(); return requestAnimationFrame(step); }

      state.time++;
      const W = canvas.width / DPR, H = canvas.height / DPR;

      // difficulty
      state.speed = state.baseSpeed + Math.min(6, Math.floor(state.score/8)*0.6);
      document.getElementById('spd').textContent = (state.speed/state.baseSpeed).toFixed(1)+"x";

      // bg
      ctx.save();
      ctx.clearRect(0,0,W,H);
      drawStars(W, H, state.time);

      // physics
      player.vy += player.gravity;
      player.y += player.vy;

      const floor = H - 40, ceiling = 20;
      if (player.y + player.h >= floor) { player.y = floor - player.h; player.vy=0; player.grounded=true; player.jumpsLeft=2; player.coyoteTime=0; }
      else { if (player.grounded && player.vy>0) player.grounded=false; if (!player.grounded) player.coyoteTime = Math.max(0, player.coyoteTime-1); if (player.y <= ceiling){ player.y = ceiling; player.vy = Math.max(0, player.vy); } }

      if (player.jumpBuffer>0){ if (tryJump()) player.jumpBuffer = 0; else player.jumpBuffer--; }

      player.trail.push({x:player.x+player.w/2, y:player.y+player.h/2, life:14});
      if (player.trail.length>40) player.trail.shift();
      for(const t of player.trail) t.life-=1;

      if (spawnTimer<=0){ spawnObstacle(); spawnTimer = state.spawnEvery - Math.min(40, Math.floor(state.score/4)); }
      else spawnTimer -= 1;

      for (const ob of state.obstacles){ ob.x -= state.speed; if(!ob.passed && ob.x + ob.w < player.x) { ob.passed=true; state.score++; if(state.score%6===0) spawnBurst(player.x+player.w/2, player.y, 12,'#6ae3ff'); } }
      state.obstacles = state.obstacles.filter(ob => ob.x + ob.w > -10);
      document.getElementById('score').textContent = state.score;
      document.getElementById('best').textContent = state.best;

      // collisions
      for (const ob of state.obstacles){
        if (ob.top>0){ const rectTop = {x:ob.x, y:0, w:ob.w, h:ob.top}; if (rectsOverlap(player, rectTop)) return gameOver(); }
        if (ob.bottom>0){ const rectBot = {x:ob.x, y:H - ob.bottom, w:ob.w, h:ob.bottom}; if (rectsOverlap(player, rectBot)) return gameOver(); }
      }

      drawFloor(W,H);
      drawObstacles(W,H);
      drawPlayer();
      updateParticles();
      drawParticles();

      // post-physics: coyote time
      if (prevGrounded && !player.grounded){ player.coyoteTime = 8; }
      prevGrounded = player.grounded;

      ctx.restore();
      requestAnimationFrame(step);
    }

    // ====== Drawing helpers ======
    function drawStars(W,H,t){
      ctx.fillStyle = '#0b1020'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#13203a';
      for (let i=0;i<80;i++){
        const x = (i*127 + t*0.2) % (W+100) - 50;
        const y = (i*53 % H);
        ctx.globalAlpha = 0.15 + (i%5)*0.05;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.globalAlpha = 1;
    }
    function drawFloor(W,H){ const y = H-40; ctx.strokeStyle = '#1f2b4d'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }
    function drawObstacles(W,H){
      for (const ob of state.obstacles){
        const grd = ctx.createLinearGradient(ob.x,0, ob.x+ob.w,0);
        grd.addColorStop(0,'#2a3d6b'); grd.addColorStop(1,'#234066');
        ctx.fillStyle = grd;
        if (ob.top>0) ctx.fillRect(ob.x, 0, ob.w, ob.top);
        if (ob.bottom>0) ctx.fillRect(ob.x, H - ob.bottom, ob.w, ob.bottom);
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        if (ob.top>0) ctx.fillRect(ob.x+4, 0, 3, ob.top);
        if (ob.bottom>0) ctx.fillRect(ob.x+4, H - ob.bottom, 3, ob.bottom);
      }
    }
    function drawPlayer(){
      for (const t of player.trail){ const a = Math.max(0, t.life/14); ctx.fillStyle = `rgba(138,247,141,${0.08*a})`; ctx.beginPath(); ctx.arc(t.x, t.y, (14-t.life)*0.6, 0, Math.PI*2); ctx.fill(); }
      roundRect(ctx, player.x, player.y, player.w, player.h, 6, '#0b1020', player.color);
      ctx.fillStyle = '#072e2a'; ctx.fillRect(player.x+player.w*0.62, player.y+player.h*0.30, 4, 4);
    }
    function drawParticles(){ for (const p of state.particles){ ctx.globalAlpha = Math.max(0, p.life/40); ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3);} ctx.globalAlpha = 1; }
    function drawSplash(){
      const W = canvas.width / DPR, H = canvas.height / DPR;
      ctx.clearRect(0,0,W,H); drawStars(W,H,state.time++); drawFloor(W,H);
      ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#bfe8ff'; ctx.font = '700 42px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('DOUBLE JUMP', W/2, H/2 - 20);
      ctx.font = '400 18px system-ui'; ctx.fillStyle = '#bde1c5';
      ctx.fillText('กด Space / คลิก เพื่อเริ่ม & กระโดด (กระโดดซ้ำกลางอากาศได้)', W/2, H/2 + 16);
    }
    function drawPaused(){
      const W = canvas.width / DPR, H = canvas.height / DPR;
      ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff'; ctx.font = '700 28px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('หยุดชั่วคราว', W/2, H/2);
    }
    function gameOver(){
      state.running=false; spawnBurst(player.x+player.w/2, player.y+player.h/2, 38, '#ff7a93');
      state.best = Math.max(state.best, state.score);
      localStorage.setItem('dj_best', String(state.best));
      drawGameOver();
    }
    function drawGameOver(){
      const W = canvas.width / DPR, H = canvas.height / DPR;
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.textAlign = 'center'; ctx.fillStyle = '#ffd6dd'; ctx.font = '700 36px system-ui';
      ctx.fillText('Game Over', W/2, H/2 - 10);
      ctx.fillStyle = '#c7f5ff'; ctx.font = '500 18px system-ui';
      ctx.fillText(`คะแนน: ${state.score}  |  ดีที่สุด: ${state.best}`, W/2, H/2 + 22);
      ctx.fillStyle = '#bfe8ff';
      ctx.fillText('กด ▶ เริ่ม / กด Space เพื่อเล่นใหม่', W/2, H/2 + 48);
    }

    // ====== Utils ======
    function rectsOverlap(a, b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    function roundRect(ctx,x,y,w,h,r,stroke,fill){
      ctx.beginPath();
      ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
      if (fill){ ctx.fillStyle = fill; ctx.fill(); }
      if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
    }
    function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }
    function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    // ====== Buttons ======
    document.getElementById('startBtn').addEventListener('click', ()=>{ resetGame(); });
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    function togglePause(){ if(!state.running) return; state.paused = !state.paused; }

   // ====== Auto start game loop on load ======
window.addEventListener('load', ()=>{
  resetGame();
  requestAnimationFrame(step);
});

// ให้ปุ่ม ▶ เริ่ม / เล่นใหม่ สั่งเริ่มลูปด้วย
document.getElementById('startBtn').addEventListener('click', ()=>{
  resetGame();
  requestAnimationFrame(step);
});

  </script>
</body>
</html>
