<!DOCTYPE html>
<html lang="th">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Double-Jump Obstacle Runner</title>
  <style>
    :root { --bg:#0b1020; --fg:#e6f0ff; --accent:#6ae3ff; --accent2:#8af78d; --danger:#ff7a93; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b1020,#0a0f1a);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";color:var(--fg)}
    .wrap{max-width:960px;margin:0 auto;padding:16px}
    h1{font-size:clamp(20px,3vw,28px);margin:12px 0 4px}
    .panel{display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap}
    .btn{appearance:none;border:none;background:linear-gradient(135deg,var(--accent),#62a8ff);color:#032; padding:10px 14px;border-radius:14px;font-weight:700;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.25);transition:transform .1s ease,filter .2s ease}
    .btn:hover{filter:saturate(1.2)}
    .btn:active{transform:translateY(1px)}
    .stat{display:flex;gap:10px;align-items:center}
    .badge{background:#0f172a;border:1px solid #19324f;color:#bfe8ff;padding:8px 10px;border-radius:12px;font-weight:600}
    canvas{width:100%;height:auto;border-radius:18px;display:block;background:radial-gradient(60% 120% at 50% -10%, #1b2442 0%, #0b1020 60%);}    
    .hint{opacity:.85;font-size:14px;margin:8px 0 0}
    .credits{opacity:.6;font-size:13px;margin-top:6px}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Double-Jump Obstacle Runner</h1>
    <div class="panel">
      <div class="stat">
        <span class="badge">คะแนน: <span id="score">0</span></span>
        <span class="badge">ดีที่สุด: <span id="best">0</span></span>
        <span class="badge">ความเร็ว: <span id="spd">1.0x</span></span>
      </div>
      <div class="stat">
        <button class="btn" id="startBtn">▶ เริ่ม / เล่นใหม่</button>
        <button class="btn" id="pauseBtn">⏸ หยุดชั่วคราว (P)</button>
      </div>
    </div>
    <canvas id="game" width="960" height="540"></canvas>
    <p class="hint">ควบคุม: <strong>Space / W / ↑ / คลิก / แตะ</strong> เพื่อกระโดด (กดซ้ำกลางอากาศเพื่อ <strong>Double Jump</strong>) กด <strong>P</strong> เพื่อหยุดชั่วคราว</p>
    <p class="credits">อุปสรรคเป็นเสาทั้งด้านบนและด้านล่าง ความสูง/ช่องว่างสุ่ม ปรับความเร็วตามคะแนน มีระบบ <em>coyote time</em> และ <em>jump buffer</em> ให้ควบคุมลื่นไหล</p>
  </div>

  <script>
    // ====== Canvas + DPR ======
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    function fitCanvasToDPR() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const { width, height } = canvas;
      ctx.setTransform(dpr,0,0,dpr,0,0);
      return dpr;
    }
    let DPR = fitCanvasToDPR();
    addEventListener('resize', () => { DPR = fitCanvasToDPR(); });

    // ====== Game State ======
    const state = {
      running:false, paused:false, time:0, score:0, best: Number(localStorage.getItem('dj_best')||0),
      speed: 5, baseSpeed:5, spawnEvery: 80, obstacles:[], particles:[],
    };

    // ====== Player ======
    const player = {
      x: 180, y: 360, w: 24, h: 24, vx:0, vy:0,
      gravity: 0.6, jumpV: -10.5, jump2V: -9.0,
      grounded:false, jumpsLeft:2, coyoteTime:0, jumpBuffer:0,
      color:'#8af78d', trail:[]
    };

    function resetGame(){
      state.running = true; state.paused=false; state.time=0; state.score=0;
      state.speed = state.baseSpeed; state.obstacles.length=0; state.particles.length=0;
      player.y = 360; player.vx=0; player.vy=0; player.grounded=false; player.jumpsLeft=2; player.coyoteTime=0; player.jumpBuffer=0; player.trail.length=0;
    }

    // ====== Input ======
    function wantJump(){ player.jumpBuffer = 8; }
    addEventListener('keydown', (e)=>{ 
      if(['Space','KeyW','ArrowUp'].includes(e.code)) { e.preventDefault(); wantJump(); }
      if(e.code==='KeyP') togglePause();
    });
    addEventListener('mousedown', wantJump);
    addEventListener('touchstart', (e)=>{ e.preventDefault(); wantJump(); }, {passive:false});

    function tryJump(){
      if (player.grounded || player.coyoteTime>0) {
        player.vy = player.jumpV; player.grounded=false; player.jumpsLeft=1; player.coyoteTime=0;
        spawnBurst(player.x+player.w/2, player.y+player.h, 10, '#8af78d'); return true;
      } else if (player.jumpsLeft>0) {
        player.vy = player.jump2V; player.jumpsLeft=0;
        spawnBurst(player.x+player.w/2, player.y+player.h, 10, '#6ae3ff'); return true;
      }
      return false;
    }

    // ====== Obstacles (top & bottom) ======
function drawObstacles(W,H){
  const floor = H - 40; // เส้นพื้นจริง
  for (const ob of state.obstacles){
    const grd = ctx.createLinearGradient(ob.x,0, ob.x+ob.w,0);
    grd.addColorStop(0,'#2a3d6b'); grd.addColorStop(1,'#234066');
    ctx.fillStyle = grd;

    // เสาบน
    if (ob.top>0) ctx.fillRect(ob.x, 0, ob.w, ob.top);

    // เสาล่าง: อ้างจาก floor ขึ้นไป
    if (ob.bottom>0) ctx.fillRect(ob.x, floor - ob.bottom, ob.w, ob.bottom);

    // ไฮไลต์เล็กน้อย
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    if (ob.top>0) ctx.fillRect(ob.x+4, 0, 3, ob.top);
    if (ob.bottom>0) ctx.fillRect(ob.x+4, floor - ob.bottom, 3, ob.bottom);
  }
}

  // ควบคุมความยาก: ช่องแคบลงเมื่อคะแนนสูง
  const diff = Math.min(1, state.score / 40);
  const CLEARANCE = 78 - diff * 30;
  const GAP_MIN = Math.max(PLAYER_H + CLEARANCE, 100 - diff * 20);
  const GAP_MAX = Math.min(250 - diff * 50, (floor - ceiling) - SAFE_PAD * 2);

  const MIN_CENTER = ceiling + SAFE_PAD + (PLAYER_H + CLEARANCE) / 2;
  const MAX_CENTER = floor   - SAFE_PAD - (PLAYER_H + CLEARANCE) / 2;

  const w = rand(46, 70);
  const x = (canvas.width / DPR) + w;

  // สุ่มลักษณะเสา (เน้นเสาล่างสูง)
  const modeRand = Math.random();
  let mode = "pair";
  if (modeRand < 0.15) mode = "singleTop";
  else if (modeRand < 0.45) mode = "singleBottom"; // ล่างเดี่ยวบ่อยขึ้น

  const gap = rand(Math.floor(GAP_MIN), Math.floor(GAP_MAX));

  // bias ให้เสาล่างสูงบ่อยขึ้น
  let center;
  if (Math.random() < (0.55 + 0.25 * diff)) {
    const biasDown = 25 + Math.floor(45 * diff);
    const biasedMin = Math.min(MAX_CENTER, ((MIN_CENTER + MAX_CENTER) / 2));
    const biasedMax = Math.min(MAX_CENTER, floor - SAFE_PAD - (PLAYER_H + CLEARANCE) / 2);
    center = rand(Math.floor(biasedMin), Math.floor(Math.max(biasedMin, biasedMax))) + biasDown;
    center = Math.min(center, MAX_CENTER);
  } else {
    center = rand(Math.floor(MIN_CENTER), Math.floor(MAX_CENTER));
  }

  let topLen = Math.max(0, Math.floor(center - gap / 2));
  let bottomLen = Math.max(0, Math.floor(floor - (center + gap / 2)));

  if (mode === "singleTop")   { bottomLen = 0; topLen = Math.max(topLen, rand(90, 360)); }
  if (mode === "singleBottom"){ topLen = 0;   bottomLen = Math.max(bottomLen, rand(110, 360)); }

  const MIN_PASS = PLAYER_H + CLEARANCE;
  const actualGap = (floor - bottomLen) - topLen;
  if (actualGap < MIN_PASS) {
    const fix = Math.ceil((MIN_PASS - actualGap) / 2);
    topLen = Math.max(0, topLen - fix);
    bottomLen = Math.max(0, bottomLen - fix);
  }

  // เสาล่างเฉลี่ยสูงขึ้นบ่อย
  if (mode !== "singleTop" && Math.random() < (0.35 + 0.25 * diff)) {
    const targetBottom = rand(110, Math.min(300, floor - (MIN_PASS + ceiling)));
    bottomLen = clamp(targetBottom, 0, floor - MIN_PASS - ceiling);
    topLen = Math.max(0, floor - bottomLen - MIN_PASS - rand(0, 12));
  }

  state.obstacles.push({ x, w, top: topLen, bottom: bottomLen, passed: false });
}

  // ถ้าสุ่มครบ 20 ครั้งแล้วยังไม่มั่นใจ ให้สร้าง "เสาล่างสั้น ๆ" การันตีผ่านได้
  state.obstacles.push({
    x, w,
    top: 0,
    bottom: 80,  // เสาล่างเตี้ย ๆ
    passed:false
  });
}



    // ====== Particles ======
    function spawnBurst(x,y,n,color){
      for(let i=0;i<n;i++){
        state.particles.push({x,y, vx:(Math.random()*2-1)*2, vy:-(Math.random()*2)*1.5, life: 30+Math.random()*20, color});
      }
    }
    function updateParticles(){
      for (const p of state.particles){ p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.life-=1; }
      state.particles = state.particles.filter(p=>p.life>0);
    }

    // ====== Loop ======
    let spawnTimer = 0, prevGrounded = true;
    function step(){
      if(!state.running){ drawSplash(); return requestAnimationFrame(step); }
      if(state.paused){ drawPaused(); return requestAnimationFrame(step); }

      state.time++;
      const W = canvas.width / DPR, H = canvas.height / DPR;

      // difficulty
      state.speed = state.baseSpeed + Math.min(6, Math.floor(state.score/8)*0.6);
      document.getElementById('spd').textContent = (state.speed/state.baseSpeed).toFixed(1)+"x";

      // bg
      ctx.save();
      ctx.clearRect(0,0,W,H);
      drawStars(W, H, state.time);

      // physics
      player.vy += player.gravity;
      player.y += player.vy;

      const floor = H - 40, ceiling = 20;
      if (player.y + player.h >= floor) { player.y = floor - player.h; player.vy=0; player.grounded=true; player.jumpsLeft=2; player.coyoteTime=0; }
      else { if (player.grounded && player.vy>0) player.grounded=false; if (!player.grounded) player.coyoteTime = Math.max(0, player.coyoteTime-1); if (player.y <= ceiling){ player.y = ceiling; player.vy = Math.max(0, player.vy); } }

      if (player.jumpBuffer>0){ if (tryJump()) player.jumpBuffer = 0; else player.jumpBuffer--; }

      player.trail.push({x:player.x+player.w/2, y:player.y+player.h/2, life:14});
      if (player.trail.length>40) player.trail.shift();
      for(const t of player.trail) t.life-=1;

      if (spawnTimer <= 0) {
  spawnObstacle();
  // ถี่ขึ้นเรื่อย ๆ ตามคะแนน
  const minSpawn = 55; // ยิ่งน้อยยิ่งถี่ (ปรับได้ระหว่าง 50–70)
  const scale = Math.min(60, Math.floor(state.score / 2)); // ความถี่เพิ่มตามคะแนน
  spawnTimer = Math.max(minSpawn, state.spawnEvery - scale);
} else {
  spawnTimer -= 1;
}

      for (const ob of state.obstacles){ ob.x -= state.speed; if(!ob.passed && ob.x + ob.w < player.x) { ob.passed=true; state.score++; if(state.score%6===0) spawnBurst(player.x+player.w/2, player.y, 12,'#6ae3ff'); } }
      state.obstacles = state.obstacles.filter(ob => ob.x + ob.w > -10);
      document.getElementById('score').textContent = state.score;
      document.getElementById('best').textContent = state.best;

      // collisions
      for (const ob of state.obstacles){
        if (ob.top>0){ const rectTop = {x:ob.x, y:0, w:ob.w, h:ob.top}; if (rectsOverlap(player, rectTop)) return gameOver(); }
        if (ob.bottom>0){ const rectBot = {x:ob.x, y:H - ob.bottom, w:ob.w, h:ob.bottom}; if (rectsOverlap(player, rectBot)) return gameOver(); }
      }

      drawFloor(W,H);
      drawObstacles(W,H);
      drawPlayer();
      updateParticles();
      drawParticles();

      // post-physics: coyote time
      if (prevGrounded && !player.grounded){ player.coyoteTime = 8; }
      prevGrounded = player.grounded;

      ctx.restore();
      requestAnimationFrame(step);
    }

    // ====== Drawing helpers ======
    function drawStars(W,H,t){
      ctx.fillStyle = '#0b1020'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#13203a';
      for (let i=0;i<80;i++){
        const x = (i*127 + t*0.2) % (W+100) - 50;
        const y = (i*53 % H);
        ctx.globalAlpha = 0.15 + (i%5)*0.05;
        ctx.fillRect(x, y, 2, 2);
      }
      ctx.globalAlpha = 1;
    }
    function drawFloor(W,H){ const y = H-40; ctx.strokeStyle = '#1f2b4d'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(0,y+0.5); ctx.lineTo(W,y+0.5); ctx.stroke(); }
    function drawObstacles(W,H){
      for (const ob of state.obstacles){
        const grd = ctx.createLinearGradient(ob.x,0, ob.x+ob.w,0);
        grd.addColorStop(0,'#2a3d6b'); grd.addColorStop(1,'#234066');
        ctx.fillStyle = grd;
        if (ob.top>0) ctx.fillRect(ob.x, 0, ob.w, ob.top);
        if (ob.bottom>0) ctx.fillRect(ob.x, H - ob.bottom, ob.w, ob.bottom);
        ctx.fillStyle = 'rgba(255,255,255,0.06)';
        if (ob.top>0) ctx.fillRect(ob.x+4, 0, 3, ob.top);
        if (ob.bottom>0) ctx.fillRect(ob.x+4, H - ob.bottom, 3, ob.bottom);
      }
    }
    function drawPlayer(){
      for (const t of player.trail){ const a = Math.max(0, t.life/14); ctx.fillStyle = `rgba(138,247,141,${0.08*a})`; ctx.beginPath(); ctx.arc(t.x, t.y, (14-t.life)*0.6, 0, Math.PI*2); ctx.fill(); }
      roundRect(ctx, player.x, player.y, player.w, player.h, 6, '#0b1020', player.color);
      ctx.fillStyle = '#072e2a'; ctx.fillRect(player.x+player.w*0.62, player.y+player.h*0.30, 4, 4);
    }
    function drawParticles(){ for (const p of state.particles){ ctx.globalAlpha = Math.max(0, p.life/40); ctx.fillStyle = p.color; ctx.fillRect(p.x, p.y, 3, 3);} ctx.globalAlpha = 1; }
    function drawSplash(){
      const W = canvas.width / DPR, H = canvas.height / DPR;
      ctx.clearRect(0,0,W,H); drawStars(W,H,state.time++); drawFloor(W,H);
      ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#bfe8ff'; ctx.font = '700 42px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('DOUBLE JUMP', W/2, H/2 - 20);
      ctx.font = '400 18px system-ui'; ctx.fillStyle = '#bde1c5';
      ctx.fillText('กด Space / คลิก เพื่อเริ่ม & กระโดด (กระโดดซ้ำกลางอากาศได้)', W/2, H/2 + 16);
    }
    function drawPaused(){
      const W = canvas.width / DPR, H = canvas.height / DPR;
      ctx.fillStyle = 'rgba(0,0,0,0.4)'; ctx.fillRect(0,0,W,H);
      ctx.fillStyle = '#fff'; ctx.font = '700 28px system-ui'; ctx.textAlign = 'center';
      ctx.fillText('หยุดชั่วคราว', W/2, H/2);
    }
    function gameOver(){
      state.running=false; spawnBurst(player.x+player.w/2, player.y+player.h/2, 38, '#ff7a93');
      state.best = Math.max(state.best, state.score);
      localStorage.setItem('dj_best', String(state.best));
      drawGameOver();
    }
    function drawGameOver(){
      const W = canvas.width / DPR, H = canvas.height / DPR;
      ctx.fillStyle = 'rgba(0,0,0,0.55)'; ctx.fillRect(0,0,W,H);
      ctx.textAlign = 'center'; ctx.fillStyle = '#ffd6dd'; ctx.font = '700 36px system-ui';
      ctx.fillText('Game Over', W/2, H/2 - 10);
      ctx.fillStyle = '#c7f5ff'; ctx.font = '500 18px system-ui';
      ctx.fillText(`คะแนน: ${state.score}  |  ดีที่สุด: ${state.best}`, W/2, H/2 + 22);
      ctx.fillStyle = '#bfe8ff';
      ctx.fillText('กด ▶ เริ่ม / กด Space เพื่อเล่นใหม่', W/2, H/2 + 48);
    }

    // ====== Utils ======
    function rectsOverlap(a, b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
    function roundRect(ctx,x,y,w,h,r,stroke,fill){
      ctx.beginPath();
      ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r);
      if (fill){ ctx.fillStyle = fill; ctx.fill(); }
      if (stroke){ ctx.strokeStyle = stroke; ctx.lineWidth = 2; ctx.stroke(); }
    }
    function clamp(v,lo,hi){ return Math.max(lo, Math.min(hi, v)); }
    function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    // ====== Buttons ======
    document.getElementById('startBtn').addEventListener('click', ()=>{ resetGame(); });
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    function togglePause(){ if(!state.running) return; state.paused = !state.paused; }

   // ====== Auto start game loop on load ======
window.addEventListener('load', ()=>{
  resetGame();
  requestAnimationFrame(step);
});

// ให้ปุ่ม ▶ เริ่ม / เล่นใหม่ สั่งเริ่มลูปด้วย
document.getElementById('startBtn').addEventListener('click', ()=>{
  resetGame();
  requestAnimationFrame(step);
});

  </script>
</body>
</html>
